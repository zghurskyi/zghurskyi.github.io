---
layout: post
title:  "Java concurrency tools"
excerpt: "In the post I will give practical comparison of using different Java classes for implementing the same toy problem - finding sum of integers in given range."
modified:   2019-09-27 12:07:41
categories: [java.util.concurrent, CompletableFuture, Future, Thread, Runnable, ForkJoinPool]
comments: true
share: true
aging: true
---
<h1>Java concurrency tools</h1>

<h1>The problem</h1>
<p>Suppose we want to calculate the sum of numbers in some closed range <em>[start, end]</em>. 
To make the task interesting, let's do it concurrenlty using <em>N</em> threads.</p>

<h1>Divide and conquer</h1>
<p>From general point of view, the described problem suits very well <em>divide and conquer</em> paradigm.
So, applied to <em>sum finding problem</em>, general plan can look as follows:</p>
<ol>
  <li>divided the range into sub-ranges</li>
  <li>delegated the job of finding sum of sub-ranges to individual threads in the pool</li>
  <li>aggregate sub-ranges sums by collecting results from individual threads</li>
</ol>

<h1>Implementation alternatives</h1>
<p>The approach described above can be implemented using different tools:<p>
<ul>
  <li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html">Runnable</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html">Thread</a></li>
  <li><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html">ExecutorService</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html">Future</a></li>
  <li><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html">ExecutorService</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html">CompletableFuture</a></li>
  <li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html">ForkJoinPool</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/BaseStream.html#parallel--">Stream.parallel</a> method</li>
</ul>

<p>Of course, if you would ecounter similar problem in commercial development, the easiest method would be to just use ForkJoinPool and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/BaseStream.html#parallel--">Stream.parallel</a>.
Because, it requires minimum amount of code on your part, and relies on standard Java library, that is heavily tested and widely used.
Howerver, since I'm doing this as an exercise and just to have fun, I will do an implementation for each alternative. So, let's start.
</p>

<h2><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html">ForkJoinPool</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/BaseStream.html#parallel--">Stream.parallel</a></h2>
{% highlight java %}
import java.util.Scanner;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ForkJoinPool;
import java.util.stream.IntStream;

public class DivideAndConquerSum {

private static int sum(int rangeStart, int rangeEnd, int numberOfThreads) {
        ForkJoinPool forkJoinPool = new ForkJoinPool(numberOfThreads);
        try {
            return forkJoinPool.submit(() ->
                    IntStream.rangeClosed(rangeStart, rangeEnd)
                            .parallel()
                            .sum()
            ).get();
        } catch (InterruptedException | ExecutionException e) {
            throw new RuntimeException(e);
        }
    }

    public static void main(String[] args) {
        try (Scanner input = new Scanner(System.in)) {
            int rangeStart, rangeEnd, numberOfThreads;
            do {
                System.out.print("Enter the range start: ");
                rangeStart = input.nextInt();

                System.out.print("Enter the range end: ");
                rangeEnd = input.nextInt();

                System.out.print("Enter the number of threads: ");
                numberOfThreads = input.nextInt();
            } while (rangeStart >= rangeEnd && numberOfThreads < 1);

            System.out.println(String.format("Sum of numbers in the range [%s, %s] found in %s threads is %s",
                    rangeStart, rangeEnd, numberOfThreads, DivideAndConquerSum.sum(rangeStart, rangeEnd, numberOfThreads)));
        }
    }
}
{% endhighlight %}

<h2><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html">ExecutorService</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html">CompletableFuture</a></h2>
{% highlight java %}
import java.util.List;
import java.util.Scanner;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class DivideAndConquerSum {

    private static int sum(int rangeStart, int rangeEnd, int numberOfThreads) {
        int numberOfSubRanges = Math.min(numberOfThreads, rangeEnd - rangeStart + 1);
        int numbersPerSubRange = findNumbersPerSubRanges(rangeStart, rangeEnd, numberOfThreads);

        ExecutorService executorPool = Executors.newFixedThreadPool(numberOfSubRanges);

        List<CompletableFuture<Integer>> subRanges = IntStream.range(0, numberOfSubRanges)
                .mapToObj(subRangeIndex -> {
                    int lower = rangeStart + (subRangeIndex * numbersPerSubRange);
                    int upper = (subRangeIndex == numberOfThreads - 1) ? rangeEnd : lower + numbersPerSubRange - 1;
                    return CompletableFuture.supplyAsync(() -> IntStream.rangeClosed(lower, upper).sum(), executorPool);
                })
                .collect(Collectors.toList());

        return CompletableFuture.allOf(subRanges.toArray(new CompletableFuture[0]))
                .thenApply(v -> {
                            Integer total = subRanges.stream()
                                    .map(CompletableFuture::join)
                                    .reduce(0, Integer::sum);
                            executorPool.shutdownNow();
                            return total;
                        }
                ).join();
    }

    private static int findNumbersPerSubRanges(int rangeStart, int rangeEnd, int numberOfThreads) {
        if (numberOfThreads >= rangeEnd - rangeStart + 1) {
            return 1;
        } else {
            return (rangeEnd - rangeStart + 1) / numberOfThreads;
        }
    }

    public static void main(String[] args) {
        try (Scanner input = new Scanner(System.in)) {
            int rangeStart, rangeEnd, numberOfThreads;
            do {
                System.out.print("Enter the range start: ");
                rangeStart = input.nextInt();

                System.out.print("Enter the range end: ");
                rangeEnd = input.nextInt();

                System.out.print("Enter the number of threads: ");
                numberOfThreads = input.nextInt();
            } while (rangeStart >= rangeEnd && numberOfThreads < 1);

            System.out.println(String.format("Sum of numbers in the range [%s, %s] found in %s threads is %s",
                    rangeStart, rangeEnd, numberOfThreads, DivideAndConquerSum.sum(rangeStart, rangeEnd, numberOfThreads)));
        }
    }
}
{% endhighlight %}
                
<h2><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html">ExecutorService</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html">Future</a></h2>

{% highlight java %}
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.stream.IntStream;

public class DivideAndConquerSum {

    private static int sum(int rangeStart, int rangeEnd, int numberOfThreads) {
        int totalSum = 0;
        try {
            int numberOfSubRanges = Math.min(numberOfThreads, rangeEnd - rangeStart + 1);

            int numbersPerSubRange = findNumbersPerSubRanges(rangeStart, rangeEnd, numberOfThreads);
            List<Callable<Integer>> subRanges = new ArrayList<>();
            for (int subRangeIndex = 0; subRangeIndex < numberOfSubRanges; subRangeIndex++) {
                int lower = rangeStart + (subRangeIndex * numbersPerSubRange);
                int upper = (subRangeIndex == numberOfThreads - 1) ? rangeEnd : lower + numbersPerSubRange - 1;
                subRanges.add(() -> IntStream.rangeClosed(lower, upper).sum());
            }

            ExecutorService executorPool = Executors.newFixedThreadPool(numberOfSubRanges);
            List<Future<Integer>> resultFromParts = executorPool.invokeAll(subRanges, 10, TimeUnit.SECONDS);
            executorPool.shutdown();

            for (Future<Integer> result : resultFromParts) {
                totalSum += result.get();
            }

        } catch (Exception ex) {
            throw new RuntimeException(ex);
        }

        return totalSum;
    }

    private static int findNumbersPerSubRanges(int rangeStart, int rangeEnd, int numberOfThreads) {
        if (numberOfThreads >= rangeEnd - rangeStart + 1) {
            return 1;
        } else {
            return (rangeEnd - rangeStart + 1) / numberOfThreads;
        }
    }

    public static void main(String[] args) {
        try (Scanner input = new Scanner(System.in)) {
            int rangeStart, rangeEnd, numberOfThreads;
            do {
                System.out.print("Enter the range start: ");
                rangeStart = input.nextInt();

                System.out.print("Enter the range end: ");
                rangeEnd = input.nextInt();

                System.out.print("Enter the number of threads: ");
                numberOfThreads = input.nextInt();
            } while (rangeStart >= rangeEnd && numberOfThreads < 1);

            System.out.println(String.format("Sum of numbers in the range [%s, %s] found in %s threads is %s",
                    rangeStart, rangeEnd, numberOfThreads, DivideAndConquerSum.sum(rangeStart, rangeEnd, numberOfThreads)));
        }
    }
}
{% endhighlight %}

<h2><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html">Runnable</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html">Thread</a></h2>
<p>These are most basic tools, that could be used.</p>

{% highlight java %}
import java.util.Scanner;

public class DivideAndConquerSum {

    private static class Sum implements Runnable {
        final int lower;
        final int upper;
        int sum;

        Sum(int lower, int upper) {
            this.lower = lower;
            this.upper = upper;
        }

        @Override
        public void run() {
            for (int number = lower; number <= upper; number++) {
                sum += number;
            }
        }

        public int getSum() {
            return sum;
        }
    }

    private static int sum(int rangeStart, int rangeEnd, int numberOfThreads) {
        int numberOfSubRanges = Math.min(numberOfThreads, rangeEnd - rangeStart + 1);
        int numbersPerSubRange = findNumbersPerSubRanges(rangeStart, rangeEnd, numberOfThreads);

        Sum[] sums = new Sum[numberOfSubRanges];
        Thread[] pool = new Thread[numberOfSubRanges];

        for (int index = 0; index < numberOfSubRanges; index++) {
            int lower = rangeStart + (index * numbersPerSubRange);
            int upper = (index == numberOfThreads - 1) ? rangeEnd : lower + numbersPerSubRange - 1;

            Sum task = new Sum(lower, upper);
            sums[index] = task;

            Thread thread = new Thread(task);
            pool[index] = thread;

            thread.start();
        }

        try {
            for (Thread thread : pool) {
                thread.join();
            }
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        int totalSum = 0;
        for (Sum sum : sums) {
            totalSum += sum.getSum();
        }

        return totalSum;
    }

    private static int findNumbersPerSubRanges(int rangeStart, int rangeEnd, int numberOfThreads) {
        if (numberOfThreads >= rangeEnd - rangeStart + 1) {
            return 1;
        } else {
            return (rangeEnd - rangeStart + 1) / numberOfThreads;
        }
    }

    public static void main(String[] args) {
        try (Scanner input = new Scanner(System.in)) {
            int rangeStart, rangeEnd, numberOfThreads;
            do {
                System.out.print("Enter the range start: ");
                rangeStart = input.nextInt();

                System.out.print("Enter the range end: ");
                rangeEnd = input.nextInt();

                System.out.print("Enter the number of threads: ");
                numberOfThreads = input.nextInt();
            } while (rangeStart >= rangeEnd && numberOfThreads < 1);

            System.out.println(String.format("Sum of numbers in the range [%s, %s] found in %s threads is %s",
                    rangeStart, rangeEnd, numberOfThreads, DivideAndConquerSum.sum(rangeStart, rangeEnd, numberOfThreads)));
        }
    }
}
{% endhighlight %}

<h1>Conclusion</h1>
<p>If you would ecounter similar problem in commercial development, you should choose <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html">ForkJoinPool</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/BaseStream.html#parallel--">Stream.parallel</a> for several basic reasons:
<ul>
  <li>the produced code is most concise</li>
  <li>the produced code relies on standard Java library, that is heavily tested and widely used</li>
</ul>
<p>However, for situations a bit more complex then just finding sum of range, other approaches would be relevant:</p>
<ul>
  <li>with Java prior to Java 5 - you would use <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html">Runnable</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html">Thread</a> facilities</li>
  <li>with Java prior to Java 8 - consider using <a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html">ExecutorService</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html">Future</a> facilities</li>
  <li>with Java 8 - consider using <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html">CompletableFuture</a></li>
</ul>
</p>
