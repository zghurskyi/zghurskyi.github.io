---
layout: post
title:  "Java 8 to 11 language changes"
subtitle: "Brief highlights"
date:   2019-06-27 18:07:41
background: '/img/posts/06.jpg'
---

<h1>1. Java 8 to Java 11 language changes</h1>
<h2>1.1. Language Changes for Java SE 9</h2>

<strong>Platform module system</strong>
<p>The major change to Java 9 is the introduction of the Java Platform module system.</p>
<p>The Java Platform module system introduces a new kind of Java programming component - the module, which is a
    named, self-describing collection of code and data. Its code is organized as a set of packages containing
    types (i.e., Java classes and interfaces). Its data includes resources and other kinds of static
    information. Modules can either export or encapsulate packages, and they express dependencies on other
    modules explicitly.</p>
<p>To learn more about the Java Platform module system, see
    <a href="http://openjdk.java.net/projects/jigsaw/" rel="nofollow">Project Jigsaw</a> on OpenJDK.</p>

<strong>Collections <em>.of()</em> factory methods</strong>
<p>Java 9 introduces collection literals for the easier definition of the common collections:</p>

{% highlight java %}
List<Integer> list = List.of(1, 2, 3);
Set<String> set = Set.of("foo", "bar", "baz");
Map<String, String> map = Map.of("hello", "world");
Map<String, Integer> mapOfEntries = Map.ofEntries(Map.entry("o", 0), Map.entry("z", 1));
{% endhighlight %}

<strong>Stream API changes</strong></br>
<i>takeWhile</i>
<p>takeWhile takes elements from the initial stream while the predicate holds true.
    Meaning that when an element is encountered that does not match the predicate, the rest of the stream is
    discarded.</p>

{% highlight java %}
Stream.of(2, 4, 6, 8, 9, 10, 12)
    .takeWhile(n -> n % 2 == 0)
    .forEach(System.out::print);
// 2468
{% endhighlight %}

<i>dropWhile</i>
<p>dropWhile is essentially the opposite of takeWhile. Instead of taking elements from
    the stream until the first element which does not match the predicate, dropWhile drops these
    elements and includes the remaining elements in the returned stream.</p>

{% highlight java %}
Stream.of(2, 4, 6, 8, 9, 10, 12)
    .dropWhile(n -> n % 2 == 0)
    .forEach(System.out::print);
// 91012
{% endhighlight %}

<strong>Optional</strong></br>
<i><em>or()</em> method</i>
<p>The <em>or()</em> method gives you a fluent way of chaining behavior on <em>Optional</em>
    without checking if the value is present or not.</p>

{% highlight java %}
Optional.empty()
    .or(() -> Optional.of("Hello world"));
{% endhighlight %}

<i>Converting an <em>Optional</em> into a <em>Stream</em></i>
<p>Now it's possible to convert an <em>Optional</em> into a <em>Stream</em> containing at most one element. 
    It’s really useful if you want to use the laziness of the <em>Streams API</em>. 
    Namely, calling <em>map()</em> on the <em>Optional</em> executes the mapping function immediately, on the <em>Stream</em> - not.
</p>

{% highlight java %}
Optional<Integer> optional = Optional.of(1)
    .map(x -> x * 3); // variable contains Optional[3]

Stream<Integer> stream = Optional.of(1)
    .stream()
    .map(x -> x * 3); // variable contains lazy stream, that is not evaluated until terminal operation
{% endhighlight %}

<i><em>ifPresentOrElse()</em> method</i></br>
<p>In Java 8 you could specify the behavior you want to execute if the value in an <em>Optional</em> is present.</p>
<p>In Java 9 you can pass 2 Runnables to specify what to do if the value is present and otherwise.</p>

{% highlight java %}
Optional.empty()
    .ifPresentOrElse(
        x -> System.out.println(x), 
       () -> System.out.println("empty")); // empty
{% endhighlight %}

<strong>Process Management API</strong>
<p>Java 9 adds the 
    <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ProcessHandle.html">ProcessHandle</a> 
    class, which offers a rich API to inspect the processes.</p>

{% highlight java %}
ProcessHandle current = ProcessHandle.current();
current.pid()
// prints current process id
{% endhighlight %}

<strong>StackWalker</strong>
<p><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StackWalker.html">StackWalker</a>
    enables you to walk, filter and otherwise access stack traces in a very efficient manner</p>

{% highlight java %}
StackWalker.getInstance()
    .walk(s -> s.limit(5)
                .collect(Collectors.toList()));
{% endhighlight %}

<strong>More concise <em>try-with-resources</em> statements</strong>
<p>If you already have a resource as a final or effectively final variable, you
    can use that variable in a <em>try-with-resources</em> statement without declaring a new
    variable. An "effectively final" variable is one whose value is never changed after it is
    initialized.</p>

<p>In Java SE 7 or 8, you would declare new variables, like this:</p>

{% highlight java %}
try (Resource r1 = resource1; Resource r2 = resource2) { ... }
{% endhighlight %}

<p>In Java SE 9 and beyond, you don’t need to declare r1 and r2 in a <em>try-with-resources</em> statement:</p>

{% highlight java %}
try (resource1; resource2) { ... }
{% endhighlight %}

<strong>Private interface methods</strong>
<p>Private interface methods are supported. This support allows nonabstract methods of an interface to share code
    between them.</p>

<strong>The underscore character is not a legal name</strong>
<p>If you use the underscore character ("_") an identifier, your source code can no longer be compiled.</p>

<h2>1.2. Language Changes for Java SE 10</h2>
<p>Java SE 10 introduces support for inferring the type of local variables from the context, which makes code more
    readable and reduces the amount of required boilerplate code.</p>

<strong>Local-Variable Type Inference with <em>var</em></strong>
<p>In Java SE 10 and later, you can declare local variables with non-null initializers with the <em>var</em> identifier,
    which can help you write code that’s easier to read.</p>

{% highlight java %}
URL url = new URL("http://www.oracle.com/");
URLConnection conn = url.openConnection();
Reader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));
{% endhighlight %}

</br>
{% highlight java %}
var url = new URL("www.oracle.com");
var conn = url.openConnection();
var reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));
{% endhighlight %}

<p><em>var</em> is a reserved type name, not a keyword, which means that existing code that uses <em>var</em> 
    as a variable, method, or package name is not affected. However, code that uses <em>var</em> as a
    class or interface name is affected and the class or interface needs to be renamed.</p>
<p><em>var</em> can be used for the following types of variables:</p>
<ul>
    <li><p>Local variable declarations with initializers:</p>

{% highlight java %}
var list = new ArrayList<String>(); // infers ArrayList<String>
var stream = list.stream(); // infers Stream<String>
var path = Paths.get(fileName); // infers Path
var bytes = Files.readAllBytes(path); // infers bytes[]
{% endhighlight %}

    </li>
    <li><p>Enhanced <em>for-loop</em> indexes:</p>

{% highlight java %}
List<String> myList = Arrays.asList("a", "b", "c");
for (var element : myList) {...} // infers String
{% endhighlight %}

    </li>
    <li><p>Index variables declared in traditional <em>for-loops</em>:</p>

{% highlight java %}
for (var counter = 0; counter < 10; counter++) {...} // infers int
{% endhighlight %}

    </li>
    <li><p><em>try-with-resources</em> variable:</p>

{% highlight java %}
try (var input = new FileInputStream("validation.txt")) {...} // infers FileInputStream
{% endhighlight %}

    </li>
    <li><p>A lambda expression whose formal parameters have inferred types isimplicitly typed:</p>

{% highlight java %}
BiFunction<Integer, Integer, Integer> = (a, b) -> a + b
{% endhighlight %}

    </li>
</ul>
        
<p><strong><em>var</em> style guide:</strong> <em>var</em> should be used with caution. 
    To get more details about recommended uses, consult with official 
    <a href="https://openjdk.java.net/projects/amber/LVTIstyle.html">style guide</a>.</p>
<h2>1.3. Language Changes for Java SE 11</h2>

<strong>Implicitly typed lambda expression</strong>
<p>In Java SE 11 and later, you can declare each formal parameter 
    of an implicitly typed lambda expression with the <em>var</em> identifier:</p>

{% highlight java %}
(var a, var b) -> a + b;
{% endhighlight %}

<p>Why would we want to use <em>var</em> for lambda parameters when we could simply skip the types?</p>
<p>One benefit of uniformity is that annotations can be applied to lambda parameters:</p>

{% highlight java %}
(@Nonnull var s1, @Nullable var s2) -> s1 + s2
{% endhighlight %}

<h1>2. Java and Docker</h1>
<p>One of the key features of Docker is the ability to limit a container’s memory and CPU usage.
    Unfortunately, this is precisely where Java runs short. Let’s use an example to understand the problem. Imagine
    you have a node with 32GB of memory and you want to run a Java application with a limit
    of 1GB. If you do not provide a <em>-Xmx</em> parameter the JVM will use its default configuration:</p>
<ol>
    <li>The JVM will check the total available memory. Because the JVM is not aware of the Linux container, it
        thinks it is running on the Host machine and has access to the full 32GB of available memory.</li>
    <li>By default, the JVM will use <em>MaxMemory/4</em> which in this case is 8GB (32GB/4).</li>
    <li>As the heap size grows and goes beyond 1GB, the container will be killed by Docker ("OOM killed").</li>
    <li>Of course, an obvious solution is to fix the JVM’s heap size using <em>-Xmx</em> parameter, but that
        means you need to control memory twice, once in Docker and once in the JVM.</li>
</ol>
<p>The first workaround for this issue was released with Java 8u131 and Java 9:</p>
<ol>
    <li>Use <em>-XX:+UnlockExperimentalVMOptions</em></li>
    <li>Use <em>-XX:+UseCGroupMemoryLimitForHeap</em> which would tell the JVM to check for the cgroup memory limit to set the maximum heap size</li>
    <li>Use <em>-XX:MaxRAMFraction</em>, to limit portion of memory that can be allocated to the JVM.</li>
    <li>Finally, application should control explicitly the thread pools sizes, 
        and limit common ForkJoinPool parallelism with <em>-Djava.util.concurrent.ForkJoinPool.common.parallelism=2</em></li>
</ol>
<p>So, with Java 8u131+ and Java 9 you’d have something like:</p>

{% highlight java %}
-XX:+UnlockExperimentalVMOptions
-XX:+UseCGroupMemoryLimitForHeap
-XX:MaxRAMFraction=2
-Djava.util.concurrent.ForkJoinPool.common.parallelism=2
{% endhighlight %}

<p>Starting from Java 10 applying CPU and memory limits to containerized JVMs becomes straightforward. 
    The JVM will detect hardware capability of the container correctly, tune itself appropriately
    and make a good representation of the available capacity to the application. 
    As a result, not only CPU Sets but also CPU Shares are now examined by JVM.
    Furthermore, this becomes the default behaviour, and can only be disabled via <em>-XX:-UseContainerSupport<em> option.</p>

<h1>3. Java 11 compatible tools versions</h1>
<p>Here are the recommended minimum versions for a few tools:</p>
<ul>
    <li><strong>IntelliJ IDEA</strong>: 
        <a href="https://blog.jetbrains.com/idea/2018/06/java-11-in-intellij-idea-2018-2/" rel="nofollow">2018.2</a></li>
    <li><strong>Maven</strong>: 3.5.0
        <ul>
            <li>compiler plugin: 3.8.0</li>
            <li>surefire and failsafe: 2.22.0</li>
        </ul>
    </li>
    <li><strong>Gradle</strong>:<a href="https://docs.gradle.org/5.0/release-notes.html#java-11-runtime-support" rel="nofollow">5.0</a></li>
</ul>

<p>Some dependencies that are known to work on Java 11:</p>
<ul>
    <li><strong>Spring Boot 2.1.0</strong>
        <strong>Spring</strong>(5.1),
        <strong>Mockito</strong>(2.20.0)
    </li>
    <li><strong>Lombok v1.18.6</strong></li>
</ul>
