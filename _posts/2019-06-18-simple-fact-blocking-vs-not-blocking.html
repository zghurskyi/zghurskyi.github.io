---
layout: post
title:  "Simple fact #1: Blocking vs Not-Blocking"
subtitle: "Reactive idea in a nutshell"
date:   2019-06-18 14:45:13
background: '/img/posts/06.jpg'
---

<h1>Blocking Processing</h1>
<p>Blocking (synchronous) processing has several characteristics:</p>
<ul>
  <li>Bound to the processing thread</li>
  <li>Processing thread is waiting in case any I/O operation is performed</li>
</ul>
<img src="/img/blocking_processing.png" alt="Blocking processing">
<p>Under highload this approach has following consequences:</p>
<ul>
  <li><b>CPU & RAM resources are wasted</b>, while thread is waiting to the I/O results.</li>
  <li>If all threads are waiting, new user requests are either put to the queue or dropped down. This leads to poor user experience.</li>
  <li>If all threads are waiting, service becomes unresponsive for API clients. This leads to timeouts and API clients failure. Basically, <b>failure leads to more failure</b>.</li>
</ul>
<h1>Non-Blocking Processing</h1>
<p>Non-Blocking (aka "reactive") processing has several characteristics:</p>
<ul>
  <li>Not bound to specific processing thread</li>
  <li><b>Threads are not waiting</b> in case I/O operation is performed</li>
  <li>Threads are reused between calls</li>
</ul>
<img src="/img/non_blocking_processing.png" alt="Non-blocking processing">
<p>Under highload this approach has following consequences:</p>
<ul>
  <li>High CPU & RAM utilization</li>
  <li>Less threads are needed to serve same number of requests as in blocking case</li>
</ul>
<p>However, non-blocking procesing comes with a cost:</p>
<ul>
  <li>Backend design is complicated, since the need to track origin and arrival of responses & errors (also errors may be unnoticed). This require new design patterns to be employed (hopefully, wrapped into frameworks like <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html">Spring WebFlux</a>).</li>
  <li>Frontend design is complicated, since response(s) will come asynchronously via <a href="https://en.wikipedia.org/wiki/WebSocket">websockets</a>, <a href="https://en.wikipedia.org/wiki/Server-sent_events">server-sent events</a>, etc.</li>
</ul>

<h1>Conclusion</h1>
<ul>
  <li>In both cases response time is limited by I/O operations (filesystem, database, network) and response time of downstream services.</li>
  <li>Threads used for non-blocking processing don't wait for I/O operations to complete. This gives better resource utilization and increases throughput, compared to blocking processing.</li>
</ul>
