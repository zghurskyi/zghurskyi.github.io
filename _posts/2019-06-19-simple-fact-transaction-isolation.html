---
layout: post
title:  "Simple concept #3: Database Transaction"
subtitle: "What & How"
date:   2019-06-20 13:58:44
background: '/img/posts/06.jpg'
---

<h1>Database Transaction</h1>
<div style="background-color: #ddffdd; border-left: 6px solid #4CAF50; padding-left: 20px;">
  <p>Database Transaction represents a unit of work, that is atomic, consistent, isolated and durable (a.k.a. ACID).</p>
</div>
<p>ACID guarantees are provided by database management systems (DBMS).</p>
<ul>
  <li><b>Atomicity</b> means that operations, that constitute transaction are all either succeed or fail together. 
  So atomicity implies that there can't be situation, in which part of operations succeeded and part failed.
  </li>
  <li><b>Consistency</b> means that transaction leaves database in consistent state after execution.
  So, in practical terms, any data written to database must be valid according to integrity constraints (primary key/foreign key/unique key/etc.), cascades, triggers, and any combination thereof. 
  </li>
  <li><b>Isolation</b> determines how operations performed in a transaction are visible to other executing transactions.
  So, for example, whether data written by transaction is available for read by other concurrent transactions.
  </li>
  <li><b>Durability</b> means that after transaction is committed, database changes are saved permanently.
  So, if database crushes all committed transactions will be restored. 
  This is most often implemented by using transaction log stored in non-volatile storage. 
  And transaction is committed only after it is entered in the log.
  </li>
</ul>

<h1>Transaction states</h1>
<p>During execution database transaction goes through number of states:</p>
<img src="/img/transaction_state_machine.png" alt="Transaction state machine">
<p></p>
<h2>State transitions example</h2>
<p>Assume we have two accounts: A and B. Initially each account has 1000$ balance.However, we need to transfer 100$ from account A to account B.</p>
<p>Database transaction for above situation can be represented as follows (in pseudocode):</p>
{% highlight sql %}
BEGIN TRANSACTION
  READ(A);
  A := A - 100;
  WRITE(A);
  READ(B);
  B := B + 100;
  WRITE(B);
  COMMIT;
END TRANSACTION;
{% endhighlight %}

<p>Let's follow state transitioning for this transaction:</p>
<ol>
  <li><b>ACTIVE:</b> 
    <p>From BEGIN TRANSACTION to COMMIT instraction the transaction is in ACTIVE state.</p>
  </li>
  <li><b>PARTIALLY COMMITTED:</b>
    <p>If transaction reaches COMMIT without failures, then it goes into PARTIALLY COMMITTED state.</p>
    <p>In PARTIALLY COMMITTED state, balances will have following values: A = 900 and B = 1100
  </li>
  <li><b>FAILED</b>
    <p>Transaction may enter FAILED state:</p>
    <ul>
      <li>In ACTIVE state:
        <ul>
          <li>before WRITE(A): then A = 1000 and B = 1000</li>
          <li>after WRITE(A): then A = 900 and B = 1100</li>
          <li>before COMMIT and after WRITE(B): then A = 900 and B = 1100</li>
        </ul>
      </li>
      <li>In PARTIALLY COMMITTED state. Then balances: A = 500 and B = 1500</li>
    </ul>
  </li>
  <li><b>ABORTED</b>
    <p>The transaction in ABORTED state has to undo the changes made so far.
      So, whatever balances are at the beginning in ABORTED state, after roll back to the previous consistent state: A = 1000 and B = 1000
    </p>
  </li>
  <li><b>COMMITTED</b>
    <p>If the transaction executes COMMIT successfully, that is, if it successfully writes the new value of A and B 
      into log file or stable storage, then the transaction is said to be in COMMITTED state.
    </p>
  </li>
  <li>After entering COMMITTED or ABORTED state, transaction is terminated</li>
</ol>

<h1>Transaction failure reasons</h1>
<p>Database transaction might fail due to one or more of the following reasons</p>
<ul>
  <li>Server failure, e.g. hardware, software or network error, that causes database server to hang or crash</li>
  <li>Logical transaction failure, e.g. user aborts transaction, devision by zero etc.</li>
  <li>Concurrency failure, e.g. if transaction causes deadlock, or violates serializability</li>
  <li>Disk failure</li>
</ul>
<p>DBMS usually can recover from server failure, logical failure or concurrency failure. To deal with disk failures - disk backups needs to be maintained.</p>
</ul>
